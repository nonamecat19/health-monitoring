var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
import superjson from "superjson";
export var serializePayload = function (payload) { return superjson.stringify(payload); };
export var deserializePayload = function (payload) {
    // this check is required to support the case using the SWRDevTools component directly
    // In this case, the payload is not serialized
    return typeof payload === "string" ? superjson.parse(payload) : payload;
};
export var injectSWRCache = function (cache, watcher) {
    // intercept operations modifying the cache store
    var originalSet = cache.set;
    cache.set = function (key, value) {
        if (!isMetaCache(key)) {
            watcher(key, value);
        }
        return originalSet.call(cache, key, value);
    };
    var originalDelete = cache.delete;
    cache.delete = function (key) {
        if (!isMetaCache(key)) {
            watcher(key, undefined);
        }
        return originalDelete.call(cache, key);
    };
};
var isMetaCache = function (key) {
    return /^\$(?:ctx|len)\$/.test(key);
};
var isErrorCache = function (key) {
    return /^\$err\$/.test(key);
};
var isInfiniteCache = function (key) {
    return /\$inf\$/.test(key);
};
var isSubscriptionCache = function (key) {
    return /\$sub\$/.test(key);
};
var isIsValidatingCache = function (key) {
    return /^\$req\$/.test(key);
};
var filterMetaCacheKey = function (key) {
    var _a, _b;
    var match = key.match(/^(?:\$(?:req|swr|err)\$)?(?:\$(inf|sub)\$)(?<cacheKey>.*)?/);
    return (_b = (_a = match === null || match === void 0 ? void 0 : match.groups) === null || _a === void 0 ? void 0 : _a.cacheKey) !== null && _b !== void 0 ? _b : key;
};
var isV2CacheData = function (data) {
    return (("isValidating" in data && "isLoading" in data) ||
        // useSWRSubscription
        ("_c" in data && "_k" in data));
};
var isV1MetaCache = function (key) {
    return /^\$swr\$/.test(key);
};
// refs. https://github.com/koba04/swr-devtools/issues/48
export var convertToDevToolsCacheData = function (key, value) {
    var isInfinite = isInfiniteCache(key);
    var isSubscription = isSubscriptionCache(key);
    var infiniteKey = isInfinite ? filterMetaCacheKey(key) : undefined;
    var subscriptionKey = isSubscription ? filterMetaCacheKey(key) : undefined;
    if (value !== undefined &&
        typeof value === "object" &&
        isV2CacheData(value)) {
        // SWR v2
        // useSWRSubscription was added at 2.1.0
        return {
            key: key,
            value: __assign(__assign({}, value), { isInfinite: isInfinite, infiniteKey: infiniteKey, subscriptionKey: subscriptionKey, isSubscription: isSubscription }),
        };
    }
    else if (value !== undefined && isV1MetaCache(key)) {
        // SWR ^1.3.0 ($swr$ cache key)
        return {
            key: key.replace("$swr$", ""),
            value: __assign(__assign({}, value), { isInfinite: isInfinite, infiniteKey: infiniteKey }),
        };
    }
    else if (isErrorCache(key)) {
        // SWR <1.3.0
        return {
            key: key.replace("$err$", ""),
            value: {
                error: value,
                isInfinite: isInfinite,
                infiniteKey: infiniteKey,
            },
        };
    }
    else if (isIsValidatingCache(key)) {
        // SWR <1.3.0
        return {
            key: key.replace("$req$", ""),
            value: {
                isValidating: value,
                isInfinite: isInfinite,
                infiniteKey: infiniteKey,
            },
        };
    }
    return {
        key: key,
        value: { data: value, isInfinite: isInfinite },
    };
};
//# sourceMappingURL=swr-cache.js.map